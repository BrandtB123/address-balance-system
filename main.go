package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"unit410/api"
	"unit410/db"
	"unit410/models"
)

type BalanceResponse struct {
	Balances []struct {
		Denom  string `json:"denom"`
		Amount string `json:"amount"`
	} `json:"balances"`
}

func getOsmosisBalance(address string) (string, error) {
	// Construct the URL
	url := fmt.Sprintf("https://lcd.osmosis.zone/cosmos/bank/v1beta1/balances/%s", address)

	// Send GET request
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	// Parse response JSON
	var balanceResponse BalanceResponse
	err = json.Unmarshal(body, &balanceResponse)
	if err != nil {
		return "", err
	}

	// Find and return the balance
	for _, balance := range balanceResponse.Balances {
		if balance.Denom == "uosmo" { // Replace with the specific token symbol if needed
			return balance.Amount, nil
		}
	}

	// Return an error if the balance for the token symbol is not found
	return "", fmt.Errorf("balance not found for the specified token")
}

func chainData(chain string) ([]*models.Bal, error) {
	switch chain {
	case "near":
		api := api.NearAPI{}
		return api.GetData()
	case "audius":
		api := api.AudiusAPI{}
		return api.GetData()
	case "osmosis":
		api := api.OsmosisAPI{}
		return api.GetData()
	}
	return nil, nil
}

func main() {

	// test := api.AudiusAPI{}
	// a, _ := test.GetData()
	// fmt.Println(a)
	//fmt.Println(getOsmosisBalance("osmo1npfl4vmmmf4yqhcemz95mvqujgdnlhrlxfzhlhz2gru8g2t749xqr9zm5e"))
	// x, _ := api.HttpRequest[models.OsmosisDelegationResponse]("GET", "https://lcd.osmosis.zone/cosmos/staking/v1beta1/delegations/osmo1npfl4vmmmf4yqhcemz95mvqujgdnlhrlxfzhlhz2gru8g2t749xqr9zm5e", nil)
	// fmt.Println(x.DelegationResponses[0].Balance.Amount)

	//test := api.OsmosisAPI{}

	// NEAR WORKING
	// test := api.OsmosisAPI{}
	// test := api.AudiusAPI{}
	// // test := api.NearAPI{}
	// a, _ := test.GetData()
	// fmt.Println(a)
	db.NewDB()
	db.CreateBalancesTable()

}

// // Handle different types based on the structure of the response
// if x, ok := data.(AutoGenerated); ok {
// 	// Process AutoGenerated type
// 	fmt.Println("AutoGenerated:", x)
// }
// datad, _ := data.(AutoGenerated)
// // Find the delegated balance for the specified address
// var delegatedBalances []string
// for _, delegation := range datad.DelegationResponses {
// 	if delegation.Delegation.DelegatorAddress == address {
// 		fmt.Println(delegation.Balance.Amount)
// 		delegatedBalances = append(delegatedBalances, delegation.Balance.Amount)
// 	}
// }
// sum := big.NewInt(0)

// // Iterate over the numbers and add them to the sum
// for _, numStr := range delegatedBalances {
// 	num := new(big.Int)
// 	num.SetString(numStr, 10)
// 	sum.Add(sum, num)
// }

// fmt.Println(sum.String())
